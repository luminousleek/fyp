From 97dbf82d9b398f2c06779cdc504505176b2eb630 Mon Sep 17 00:00:00 2001
From: Isaac Lee <68138671+luminousleek@users.noreply.github.com>
Date: Thu, 22 Feb 2024 13:25:01 +0800
Subject: [PATCH] implement trusted dma pta and driver

change type and fix bugs

enable trusted dma pta config
---
 core/arch/arm/plat-zynqmp/conf.mk     |   1 +
 core/drivers/zynqmp_dma.c             | 127 ++++++++++++++++++++++++++
 core/include/drivers/zynqmp_dma.h     |  54 +++++++++++
 core/pta/sub.mk                       |   1 +
 core/pta/trusted_dma_pta.c            |  86 +++++++++++++++++
 lib/libutee/include/pta_trusted_dma.h |  21 +++++
 6 files changed, 290 insertions(+)
 create mode 100644 core/drivers/zynqmp_dma.c
 create mode 100644 core/include/drivers/zynqmp_dma.h
 create mode 100644 core/pta/trusted_dma_pta.c
 create mode 100644 lib/libutee/include/pta_trusted_dma.h

diff --git a/core/arch/arm/plat-zynqmp/conf.mk b/core/arch/arm/plat-zynqmp/conf.mk
index 4c0a33617..53ced2264 100644
--- a/core/arch/arm/plat-zynqmp/conf.mk
+++ b/core/arch/arm/plat-zynqmp/conf.mk
@@ -56,6 +56,7 @@ CFG_SHMEM_SIZE   ?= 0x10000000
 
 CFG_WITH_STATS ?= y
 CFG_CRYPTO_WITH_CE ?= y
+CFG_TRUSTED_DMA_PTA ?= y
 
 # Enable use of User AES eFuse as device key instead of PUF.
 # This is needed when images are encrypted with AES eFuse device key (AES_KEY).
diff --git a/core/drivers/zynqmp_dma.c b/core/drivers/zynqmp_dma.c
new file mode 100644
index 000000000..fa5b19905
--- /dev/null
+++ b/core/drivers/zynqmp_dma.c
@@ -0,0 +1,127 @@
+#include <drivers/zynqmp_dma.h>
+#include <kernel/delay.h>
+#include <mm/core_memprot.h>
+#include <util.h>
+
+uint32_t write_dma(void *virtual_addr, uint32_t offset, uint32_t value)
+{
+    virtual_addr[offset>>2] = value;
+
+    return 0;
+}
+
+uint32_t read_dma(void *virtual_addr, uint32_t offset)
+{
+    return virtual_addr[offset>>2];
+}
+
+uint32_t reset_dma(void *dma_virtual_addr, enum dma_channel channel)
+{
+  if (channel == S2MM_CHANNEL) {
+    return write_dma(dma_virtual_addr, S2MM_CONTROL_REGISTER, RESET_DMA);
+  } else {
+    return write_dma(dma_virtual_addr, MM2S_CONTROL_REGISTER, RESET_DMA);
+  }
+}
+
+uint32_t halt_dma(void *dma_virtual_addr, enum dma_channel channel)
+{
+  if (channel == S2MM_CHANNEL) {
+    return write_dma(dma_virtual_addr, S2MM_CONTROL_REGISTER, HALT_DMA);
+  } else {
+    return write_dma(dma_virtual_addr, MM2S_CONTROL_REGISTER, HALT_DMA);
+  }
+}
+
+uint32_t enable_all_irq(void *dma_virtual_addr, enum dma_channel channel)
+{
+  if (channel == S2MM_CHANNEL) {
+    return write_dma(dma_virtual_addr, S2MM_CONTROL_REGISTER, ENABLE_ALL_IRQ);
+  } else {
+    return write_dma(dma_virtual_addr, MM2S_CONTROL_REGISTER, ENABLE_ALL_IRQ);
+  }
+}
+
+uint32_t run_dma(void *dma_virtual_addr, enum dma_channel channel)
+{
+  if (channel == S2MM_CHANNEL) {
+    return write_dma(dma_virtual_addr, S2MM_CONTROL_REGISTER, RUN_DMA);
+  } else {
+    return write_dma(dma_virtual_addr, MM2S_CONTROL_REGISTER, RUN_DMA);
+  }
+}
+
+uint32_t set_transfer_len(void *dma_virtual_addr, uint32_t length, enum dma_channel channel)
+{
+  if (channel == S2MM_CHANNEL) {
+    return write_dma(dma_virtual_addr, S2MM_BUFF_LENGTH_REGISTER, length);
+  } else {
+    return write_dma(dma_virtual_addr, MM2S_TRNSFR_LENGTH_REGISTER, length);
+  }
+}
+
+uint32_t read_dma_status(void *dma_virtual_addr, enum dma_channel channel) {
+  if (channel == S2MM_CHANNEL) {
+    return read_dma(dma_virtual_addr, S2MM_STATUS_REGISTER);
+  } else {
+    return read_dma(dma_virtual_addr, MM2S_STATUS_REGISTER);
+  }
+}
+
+uint32_t set_transfer_mem_addr(void *dma_virtual_addr, void *phy_addr, enum dma_channel channel)
+{
+  if (channel == S2MM_CHANNEL) {
+    return write_dma(dma_virtual_addr, S2MM_DST_ADDRESS_REGISTER, phy_addr);
+  } else {
+    return write_dma(dma_virtual_addr, MM2S_SRC_ADDRESS_REGISTER, phy_addr);
+  }
+}
+
+TEE_Result dma_init(void *dma_base_addr, enum dma_channel channel)
+{
+  register_phys_mem_pgdir(MEM_AREA_IO_SEC, dma_base_addr, DMA_SIZE);
+  uintptr_t dma_virtual_addr = core_mmu_get_va(dma_base_addr, MEM_AREA_IO_SEC, DMA_SIZE);
+
+  if (!dma_virtual_addr)
+    return TEE_ERROR_GENERIC;
+
+  reset_dma(dma_virtual_addr, channel);
+  halt_dma(dma_virtual_addr, channel);
+  enable_all_irq(dma_virtual_addr, channel);
+
+  return TEE_SUCCESS;
+}
+
+TEE_Result dma_sync(void *dma_base_addr, enum dma_channel channel)
+{
+  uintptr_t dma_virtual_addr = core_mmu_get_va(dma_base_addr, MEM_AREA_IO_SEC, DMA_SIZE);
+  uint64_t tref = timeout_init_us(DMA_DONE_TIMEOUT_USEC);
+  uint32_t status = 0;
+
+  if (!dma_virtual_addr)
+    return TEE_ERROR_GENERIC;
+  
+  while (!timeout_elapsed(tref)) {
+    status = read_dma_status(dma_virtual_addr, channel);
+    if ((status & IOC_IRQ_FLAG) && (status & IDLE_FLAG)) {
+      return TEE_SUCCESS;
+    }
+  }
+
+  return TEE_ERROR_GENERIC;
+}
+
+TEE_Result dma_transfer(void *dma_base_addr, void *transfer_mem_addr, uint32_t length, 
+                        enum dma_channel channel)
+{
+  uintptr_t dma_virtual_addr = core_mmu_get_va(dma_base_addr, MEM_AREA_IO_SEC, DMA_SIZE);
+
+  if (!dma_virtual_addr)
+    return TEE_ERROR_GENERIC;
+
+  set_transfer_mem_addr(dma_virtual_addr, transfer_mem_addr, channel);
+  run_dma(dma_virtual_addr, channel);
+  set_transfer_len(dma_virtual_addr, length, channel);
+
+  return TEE_SUCCESS;
+}
diff --git a/core/include/drivers/zynqmp_dma.h b/core/include/drivers/zynqmp_dma.h
new file mode 100644
index 000000000..fa65c6791
--- /dev/null
+++ b/core/include/drivers/zynqmp_dma.h
@@ -0,0 +1,54 @@
+#include <tee_api_types.h>
+
+#ifndef __DRIVERS_ZYNQMP_DMA_H_
+#define __DRIVERS_ZYNQMP_DMA_H_
+
+enum dma_channel {
+  S2MM_CHANNEL = 0,
+  MM2S_CHANNEL = 1
+};
+
+/* DMA registers */
+#define MM2S_CONTROL_REGISTER       0x00
+#define MM2S_STATUS_REGISTER        0x04
+#define MM2S_SRC_ADDRESS_REGISTER   0x18
+#define MM2S_TRNSFR_LENGTH_REGISTER 0x28
+
+#define S2MM_CONTROL_REGISTER       0x30
+#define S2MM_STATUS_REGISTER        0x34
+#define S2MM_DST_ADDRESS_REGISTER   0x48
+#define S2MM_BUFF_LENGTH_REGISTER   0x58
+
+#define IOC_IRQ_FLAG                1<<12
+#define IDLE_FLAG                   1<<1
+
+#define STATUS_HALTED               0x00000001
+#define STATUS_IDLE                 0x00000002
+#define STATUS_SG_INCLDED           0x00000008
+#define STATUS_DMA_INTERNAL_ERR     0x00000010
+#define STATUS_DMA_SLAVE_ERR        0x00000020
+#define STATUS_DMA_DECODE_ERR       0x00000040
+#define STATUS_SG_INTERNAL_ERR      0x00000100
+#define STATUS_SG_SLAVE_ERR         0x00000200
+#define STATUS_SG_DECODE_ERR        0x00000400
+#define STATUS_IOC_IRQ              0x00001000
+#define STATUS_DELAY_IRQ            0x00002000
+#define STATUS_ERR_IRQ              0x00004000
+
+#define HALT_DMA                    0x00000000
+#define RUN_DMA                     0x00000001
+#define RESET_DMA                   0x00000004
+#define ENABLE_IOC_IRQ              0x00001000
+#define ENABLE_DELAY_IRQ            0x00002000
+#define ENABLE_ERR_IRQ              0x00004000
+#define ENABLE_ALL_IRQ              0x00007000
+
+#define DMA_SIZE                    0x10000
+#define DMA_DONE_TIMEOUT_USEC       3000000
+
+TEE_Result dma_init(void *dma_base_addr, enum dma_channel channel);
+TEE_Result dma_sync(void *dma_base_addr, enum dma_channel channel);
+TEE_Result dma_transfer(void *dma_base_addr, void *transfer_mem_addr, uint32_t length, 
+                        enum dma_channel channel);
+
+#endif
\ No newline at end of file
diff --git a/core/pta/sub.mk b/core/pta/sub.mk
index a20bc6c29..2e5b49059 100644
--- a/core/pta/sub.mk
+++ b/core/pta/sub.mk
@@ -14,5 +14,6 @@ srcs-$(CFG_APDU_PTA) += apdu.c
 srcs-$(CFG_SCMI_PTA) += scmi.c
 srcs-$(CFG_HWRNG_PTA) += hwrng.c
 srcs-$(CFG_RTC_PTA) += rtc.c
+srcs-$(CFG_TRUSTED_DMA_PTA) += trusted_dma_pta.c
 
 subdirs-y += bcm
diff --git a/core/pta/trusted_dma_pta.c b/core/pta/trusted_dma_pta.c
new file mode 100644
index 000000000..e3a69eb2c
--- /dev/null
+++ b/core/pta/trusted_dma_pta.c
@@ -0,0 +1,86 @@
+#include <kernel/pseudo_ta.h>>
+#include <drivers/zynqmp_dma.h>
+#include <pta_trusted_dma.h>
+#include <tee_api_defines.h>
+#include <tee_api_types.h>
+
+#define PTA_NAME "trusted_dma.pta"
+
+static TEE_Result pta_cmd_trusted_dma_init(uint32_t param_types, TEE_Param params [TEE_NUM_PARAMS])
+{
+  void* dma_base_addr;
+  enum dma_channel channel;
+  const uint32_t exp_pt = TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_INPUT,
+						TEE_PARAM_TYPE_VALUE_INPUT,
+						TEE_PARAM_TYPE_NONE,
+						TEE_PARAM_TYPE_NONE);
+
+  if (param_types != exp_pt)
+    return TEE_ERROR_BAD_PARAMETERS;
+
+  dma_base_addr = params[0].memref.buffer;
+  channel = (params[1].value.a == 1) ? MM2S_CHANNEL : S2MM_CHANNEL;
+
+  return dma_init(dma_base_addr, channel);
+}
+
+static TEE_Result pta_cmd_trusted_dma_sync(uint32_t param_types, TEE_Param params [TEE_NUM_PARAMS])
+{
+  void* dma_base_addr;
+  enum dma_channel channel;
+  const uint32_t exp_pt = TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_INPUT,
+						TEE_PARAM_TYPE_VALUE_INPUT,
+						TEE_PARAM_TYPE_NONE,
+						TEE_PARAM_TYPE_NONE);
+
+  if (param_types != exp_pt)
+    return TEE_ERROR_BAD_PARAMETERS;
+
+  dma_base_addr = params[0].memref.buffer;
+  channel = (params[1].value.a == 1) ? MM2S_CHANNEL : S2MM_CHANNEL;
+
+  return dma_sync(dma_base_addr, channel);
+}
+
+static TEE_Result pta_cmd_trusted_dma_transfer(uint32_t param_types, TEE_Param params [TEE_NUM_PARAMS])
+{
+  void* dma_base_addr;
+  void* transfer_mem_addr;
+  uint32_t transfer_length;
+  enum dma_channel channel;
+  const uint32_t exp_pt = TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_INPUT,
+						TEE_PARAM_TYPE_MEMREF_INPUT,
+						TEE_PARAM_TYPE_VALUE_INPUT,
+						TEE_PARAM_TYPE_NONE);
+
+  if (param_types != exp_pt)
+    return TEE_ERROR_BAD_PARAMETERS;
+
+  dma_base_addr = params[0].memref.buffer;
+  transfer_mem_addr = params[1].memref.buffer;
+  transfer_length = params[1].memref.size;
+  channel = (params[2].value.a == 1) ? MM2S_CHANNEL : S2MM_CHANNEL;
+
+  return dma_transfer(dma_base_addr, transfer_mem_addr, transfer_length, channel);
+}
+
+TEE_Result invoke_command(void *session __unused, uint32_t cmd_id,
+				      uint32_t param_types,
+				      TEE_Param params[TEE_NUM_PARAMS])
+{
+	switch (cmd_id) {
+  case PTA_CMD_TRUSTED_DMA_INIT:
+    return pta_cmd_trusted_dma_init(param_types, params);
+	case PTA_CMD_TRUSTED_DMA_SYNC:
+		return pta_cmd_trusted_dma_sync(session, param_types, params);
+	case PTA_CMD_TRUSTED_DMA_TRANSFER:
+		return pta_cmd_trusted_dma_transfer(session, param_types, params);
+	default:
+		EMSG("Command ID %#" PRIx32 " is not supported", cmd);
+		return TEE_ERROR_NOT_SUPPORTED;
+	}
+}
+
+pseudo_ta_register(.uuid = PTA_TRUSTED_DMA_UUID, .name = PTA_NAME,
+    .flags = PTA_DEFAULT_FLAGS,
+    .invoke_command_entry_point = invoke_command);
diff --git a/lib/libutee/include/pta_trusted_dma.h b/lib/libutee/include/pta_trusted_dma.h
new file mode 100644
index 000000000..55c5a23a9
--- /dev/null
+++ b/lib/libutee/include/pta_trusted_dma.h
@@ -0,0 +1,21 @@
+
+
+#ifndef __PTA_TRUSTED_DMA_H
+#define __PTA_TRUSTED_DMA_H
+
+/*
+ * identifier of the pta
+ */
+
+#define PTA_TRUSTED_DMA_UUID \
+	{ 0xe1429e6f, 0xd436, 0x4c53, \
+		{ 0xbe, 0x3b, 0x9e, 0x15, 0x36, 0x50, 0xe6, 0x1f} }
+
+/*
+ * commands
+ */
+#define PTA_CMD_TRUSTED_DMA_INIT     0x0100
+#define PTA_CMD_TRUSTED_DMA_TRANSFER 0x0101
+#define PTA_CMD_TRUSTED_DMA_SYNC     0x0102
+
+#endif /*__PTA_TRUSTED_DMA_H*/
-- 
2.34.1

